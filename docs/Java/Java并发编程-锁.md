## 1.乐观锁 

乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作(比较跟上一次的版本号，如果一样则更新)， 如果失败则要重复读-比较-写的操作。 

java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。

## 2.悲观锁 

悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。 

java 中的悲观锁就是 Synchronized,AQS 框架下的锁则是先尝试 cas 乐观锁去获取锁，获取不到,才会转换为悲观锁，如 RetreenLock。 

## 3.自旋锁 

自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等(自旋)， 

等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 

线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。 

如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 

### 3.1.自旋锁的优缺点 

自旋锁尽可能的减少线程的阻塞，这**对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升**，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换!

但是**如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了**，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁; 

### 3.2 .自旋锁时间阈值(***1.6*** 引入了适应性自旋锁) 

自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢?如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要!

JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了**适应性自旋锁**，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥 有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间(自旋计数)或进入阻塞，**如果 CPU 处于节电模式则停止自旋**，自旋时间的最坏情况是 CPU 的存储延迟(CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差)，自旋时会适当放弃线程优先级之间的差异。

自旋锁的开启 

JDK1.6 中-XX:+UseSpinning 开启; -XX:PreBlockSpin=10 为自旋次数; JDK1.7 后，去掉此参数，由 jvm 控制; 

## 4.Synchronized 同步锁

synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于**可重入锁**。
作用于方法时，锁住的是对象的实例(this);
当作用于静态方法时，锁住的是 Class 实例，又因为 Class 的相关数据存储在永久带 PermGen(jdk1.8 则是 **metaspace**)，永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程;
synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。

## 5.非公平锁

JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，**默认为非公平锁**。非公平锁实际执行的**效率要远远超出公平锁**，除非程序有特殊需要，否则最常用非公平锁的分配机制。

## 6.公平锁 

公平锁指的是锁的分配机制是公平的，**通常先对锁提出获取请求的线程会先被分配到锁**， 

ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 

## 7.可重入锁(递归锁) 

本文里面讲的是广义上的可重入锁，而不是单指 JAVA 下的 ReentrantLock。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在 JAVA 环境下ReentrantLock 和 synchronized 都是 可重入锁。 

## 8.公平锁与非公平锁

公平锁(Fair):加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得

非公平锁(Nonfair) 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待

非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列
 Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。

## 9.**ReadWriteLock** 读写锁

**为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制**，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。

读锁:如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁
写锁: 如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁!Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现
 ReentrantReadWriteLock。

## 10.共享锁和独占锁 

 java 并发包提供的加锁模式分为独占锁和共享锁。

独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。
独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。
共享锁则允许多个线程同时获取锁，并发访问 共享资源，如:ReadWriteLock。**共享锁则是一种乐观锁**，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。
AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。
java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个写操作访问，**但两者不能同时进行**。

## 11. 重量级锁(Mutex Lock)

Synchronized 是通过对象内部的一个叫做**监视器锁(monitor)**来实现的。但是监视器锁本质又是**依赖于底层的操作系统**的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。
JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。

## 12.轻量级锁 

锁的状态总共有四种:无锁状态、偏向锁、轻量级锁和重量级锁。

- 锁升级

  随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁(但是锁的升级是单向的， 也就是说只能从低到高升级，不会出现锁的降级)。
  “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，**减少传统的重量级锁使用产生的性能消耗**。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁b的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。

## 13.偏向锁

Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，**而且总是由同一线程多次获得**。偏向锁的目的是在某个线程获得锁之后，**消除这个线程锁重入(CAS)的开销**，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID 的时候依赖一次 CAS 原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁，所
以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗)。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。

## 14.分段锁

分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践

## 15.锁优化

- 减少锁持有时间
    只用在有线程安全要求的程序上加锁
- 减小锁粒度
  将大对象(这个对象可能会被很多线程访问)，拆成小对象，大大增加并行度，降低锁竞争。
   降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是
   ConcurrentHashMap。
- 锁分离
  **最常见的锁分离就是读写锁 ReadWriteLock**，根据功能进行分离成读锁和写锁，这样读读不互
  斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据
- 锁粗化
  通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完
  公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步
  和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。
- 锁消除
  锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。