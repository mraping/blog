## 异步编程

异步编程：无依赖关系的操作

异步编程提供了一个非阻塞事件驱动的模型。通过异步消除阻塞，可以让web服务响应更多请求。可以让系统更高效的执行。比如log框架，记录日志或异常时异步执行可避免影响正常业务流程的执行。



异步变成如何把线程执行结果返回是个问题，通常的做法是注册回调。

java5中引入了future支持，但它只通过阻塞的方式返回结果，或者轮询查询到任务完成后再去获得结果。为此jdk8中引入了CompletableFuture。



异步编程提供了一个非阻塞事件驱动的模型。通过异步消除阻塞，可以让web服务响应更多请求。可以让系统更高效的执行。比如log框架，记录日志或异常时异步执行可避免影响正常业务流程的执行。

异步变成如何把线程执行结果返回是个问题，通常的做法是注册回调。

java5中引入了future支持，但它只通过阻塞的方式返回结果，或者轮询查询到任务完成后再去获得结果。为此jdk8中引入了CompletableFuture。



submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。



通过future获取返回值时，会进行阻塞，直到返回执行结果，代码继续运行。

多线程并行编程：

- Java应用程序 (多线程异步执行多个逻辑)
  -  逻辑一：3秒
  -  逻辑二：2秒
  -  逻辑三：5秒

总的执行时间，取决于执行最慢的逻辑。

逻辑之间无依赖关系，可同时执行，则可以应用多线程技术进行优化。



## Runnable和Callable区别：

共同点：都是把代码逻辑包装起来交给线程去执行

不同点：

1. 两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；

2. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；

   ```java
   @FunctionalInterface
   public interface Callable<V> {
       /**
        * Computes a result, or throws an exception if unable to do so.
        *
        * @return computed result
        * @throws Exception if unable to compute a result
        */
       V call() throws Exception;
   }
   ```




## 关于多线程的一些问题

1. 用多线程的目的是什么?
   充分利用cpu资源，并发做多件事。
2. 单核cpu机器上适不适合用多线程?
   适合，如果是单线程，线程中需要等待I0时，此时CPU就空闲出来了。
3. 线程什么时候会让出cpu?
   - 阻塞时wait await等待IO
   - Sleep
   - yield
   - 结束了 
4. 线程是什么?
     一条代码执行流，完成一组代码的执行。
     这一组代码，我们往往称为一个任务。
5. cpu做的是什么工作?
     执行代码(线程将任务装入线程，线程再将其运输至CPU，CPU再来执行代码)
6. 线程是不是越多越好?
     考虑因素：造线程要不要时间?一次性使用？用完了得销毁,销毁要不要耗时间?造很多的线程，得需要空间来放它们，会不会造成内存紧张?
     - 线程在java中是一个对象，每一个java线程都需要一个操作系统线程支持。线程创建、销毁需要时间。如果创建时间+销毁时间 > 执行任务时间就很不合算。
     - java对象占用堆内存，操作系统线程占用系统内存，根据jvm规范，一个线程默认最大栈大小1M，这个栈空间是需要从系统内存中分配的。线程过多，会消耗很多的内存。
     - 操作系统需要频繁切换线程上下文(大家都想被运行)，影响性能

7. 该如何正确使用多线程?
   - 多线程目的:充分利用cpu并发做事(多做事)
   - 线程的本质:将代码送给cpu执行
   - 用合适数量的线程不断运送代码即可。
   - 这合适数量的线程就构成了一个池。
   - 有任务要执行，就放入池中，池中的一个线程将把任务运送到cpu执行。

8. 如何确定合适数量的线程?
   - 如果是计算型任务?
     cpu数量的1-2倍
     
   - 如果是I0型任务?
     则需多一些线程，要根据具体的IO阻塞时长进行考量决定。
     如tomcat中默认的最大线程数为: 200
     也可考虑根据需要在一个最小数量和最大数量间自动增减线程数
     
     



