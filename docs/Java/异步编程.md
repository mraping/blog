## 异步编程

异步编程：无依赖关系的操作

异步编程提供了一个非阻塞事件驱动的模型。通过异步消除阻塞，可以让web服务响应更多请求。可以让系统更高效的执行。比如log框架，记录日志或异常时异步执行可避免影响正常业务流程的执行。



异步变成如何把线程执行结果返回是个问题，通常的做法是注册回调。

java5中引入了future支持，但它只通过阻塞的方式返回结果，或者轮询查询到任务完成后再去获得结果。为此jdk8中引入了CompletableFuture。



异步编程提供了一个非阻塞事件驱动的模型。通过异步消除阻塞，可以让web服务响应更多请求。可以让系统更高效的执行。比如log框架，记录日志或异常时异步执行可避免影响正常业务流程的执行。

异步变成如何把线程执行结果返回是个问题，通常的做法是注册回调。

java5中引入了future支持，但它只通过阻塞的方式返回结果，或者轮询查询到任务完成后再去获得结果。为此jdk8中引入了CompletableFuture。



submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。



通过future获取返回值时，会进行阻塞，直到返回执行结果，代码继续运行。

多线程并行编程：

- Java应用程序 (多线程异步执行多个逻辑)
  -  逻辑一：3秒
  -  逻辑二：2秒
  -  逻辑三：5秒

总的执行时间，取决于执行最慢的逻辑。

逻辑之间无依赖关系，可同时执行，则可以应用多线程技术进行优化。



## Runnable和Callable区别：

共同点：都是把代码逻辑包装起来交给线程去执行

不同点：

1. 两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；
2. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；



## 多线程后的问题

控制线程数量 cpu