## 实现方式-定时任务集群

首先我们要定义定时任务集群要解决的三个问题！

1、实效性要高

2、吞吐量要大

3、服务要稳定，不能有单点故障 



架构很简单：我们把用户的订阅推送记录存储到redis集群的**sortedSet**队列里面，并且以提醒用户**提醒时间戳**作为**score**值，然后在我们个每业务server里面起一个**定时器频率是秒级，我的设定就是1s**，然后经过负载均衡之后从某个队列里面获取要推送的用户记录进行推送。下面我们分析以下这个架构

1、性能：除去带宽等其它因素，基本与机器数成线性相关。机器数量越多吞吐量越大，机器数量少时相对的吞吐量就减少。

2、实效性：提高到了秒级，效果还可以接受。

3、单点故障？不存在的！除非redis集群或者所有server全挂了。。。。

这里解析一下为什么用redis？

第一，redis 可以作为一个高性能的存储db，性能要比MySQL好很多，并且支持持久化，稳定性好。

第二，redis SortedSet队列天然支持以时间作为条件排序，完美满足我们选出要推送的记录。

首先我们以user_id作为key，然后mod队列数hash到redis SortedSet队列里面。为什么要这样呢，因为如果用户同时订阅了两张劵并且推送时间很近，这样的两条推送就可以合并成一条~，并且这样hash也相对均匀。

然后要决定队列的数量，一般正常来说我们有多少台处理的服务器就定义多少条队列。因为队列太少，会造成队列竞争，太多可能会导致记录得不到及时处理。

然而最佳实践是队列数量应该是可动态配置化的，因为线上的集群机器数是会经常变的。大促的时候我们会加机器是不是，并且业务量增长了，机器数也是会增加是不是~。所以我是借用了淘宝的diamond进行队列数的动态配置。

我们每次从队列里面取多少条记录也是可以动态配置的 

这样就可以随时根据实际的生产情况调整整个集群的吞吐量~。  所以我们的定时任务集群还是具有一个特性就是支持动态调整~。

最后一个关键组件就是负载均衡了。这个是非常重要的！因为这个做得不好就会可能导致多台机竞争同时处理一个队列，影响整个集群的效率！在时间很紧的情况下我就用了一个简单实用的利用redis一个自增key 然后 mod 队列数量算法。这样就很大程度上就保证不会有两台机器同时去竞争一条队列~.



最后我们算一下整个集群的吞吐量

10（机器数） * 2000（一次拉取数） = 20000。然后以MQ的形式把消息推送到消息中心，发MQ是异步的，算上其它处理0.5s。

其实发送20W的推送也就是10几秒的事情。

ok~ 到这里我们整个定时任务集群就差不多基本落地好了。如果你问我后面还有什么可以完善的话那就是：

1、加监控， 集群怎么可以木有监控呢，万一出问题有任务堆积怎么办~

2、加上可视化界面。

3、最好有智能调度，增加任务优先级。优先级高的任务先运行嘛。

4、资源调度，万一机器数量不够，力不从心，优先保证重要任务执行。



以上内容来自文章[想不到吧？我是这样用Redis实现消息定时推送的！](www.cnblogs.com/linlinismine/p/9214299.html)



## 有序集合(Sorted Set)的使用

有序集合(Sorted Set)是Redis一个很重要的数据结构，它用来保存需要排序的数据。例如排行榜，一个班的语文成绩，一个公司的员工工资，一个论坛的帖子等。有序集合中，每个元素都带有score（权重），以此来对元素进行排序。

有序集合有两大基本用途：排序和聚合

### 简单的使用

```json
127.0.0.1:6379> ZADD mid_test 70 "Li Lei"
(integer) 1
127.0.0.1:6379> ZADD mid_test 70 "Han Meimei"
(integer) 1
127.0.0.1:6379> ZADD mid_test 99.5 "Tom"
(integer) 1
127.0.0.1:6379> ZREVRANGEBYSCORE mid_test 100 90 WITHSCORES
1) "Tom"
2) "99.5"
127.0.0.1:6379> ZREVRANGEBYSCORE mid_test 100 90
1) "Tom"
127.0.0.1:6379> ZREVRANGEBYSCORE mid_test 99.5 99.5
1) "Tom"
```


